(require 'f)
(defun proc-info--typeof (obj)
  (cond ((and (stringp obj)
			  (file-directory-p obj))
		 'directory)
		((and (stringp obj)
			  (file-exists-p obj))
		 'file)
		(t 'text)))

(defun proc-info--file-content-match(file regex)
  (let* ((file-lines (split-string (f-read-text file) "[\r\n]+")))
	(remove-if-not (lambda (line)
					 (string-match-p regex line))
				   file-lines)))

(defun proc-info (&rest args)
  "获取/proc下的信息"
  (let ((result "/proc"))
	(dolist (arg args)
	  (cond ((eq 'directory (proc-info--typeof result))
			 (setq result (concat (file-name-as-directory result) arg)))
			((eq 'file (proc-info--typeof result))
			 (setq result (proc-info--file-content-match result arg)))
			((listp result)
			 (setq result (remove-if-not (lambda (line)
										   (string-match-p arg line))
										 result)))
			(t (error "wrong arg type:%s,result:%s" arg result)))
	  )
	(proc-info--show result)))

(defun proc-info--show (obj)
  (cond ((eq 'directory (proc-info--typeof obj))
		 (string-join (directory-files obj nil "[^.].+") "\n")) ;不显示以.开头的文件
		((eq 'file (proc-info--typeof obj))
     (f-read-text obj))
		(t (string-join obj "\n"))))

(defun create-entries-fn-by-hm-lst (ht-lst &optional id-key keys)
  (lambda ()
    (let ((keys (or keys (hash-table-keys (car ht-lst))))
          entries)
      (dolist (ht ht-lst)
        (let ((item-id (and id-key (gethash id-key ht)))
              (entry-data (mapcar (lambda (key)
                                    (gethash key ht))
                                  keys)))
          (push (list item-id (apply #'vector entry-data)) entries)))
      (reverse entries))))

(defun tabulated-list-by-hashmap (hm-lst &optional id-key keys)
  (let ((tabulated-list-entries (create-entries-fn-by-hm-lst ht-lst id-key keys)))))


(provide 'proc-info)
